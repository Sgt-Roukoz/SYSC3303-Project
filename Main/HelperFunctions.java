/**
 * HelperFunctions class contains a variety of functions related to byte array manipulation
 *
 * @author Marwan Zeid
 * @verion 2024-03-05
 */
package Main;

import java.util.ArrayList;
import java.util.Arrays;

public class HelperFunctions {

    /**
     * Generates a byte array following a specific pattern from a given String
     * @param stringMsg The string to be translated into a byte array following the pattern
     * @return Returns the generated byte array
     */
    public static byte[] generateMsg(String stringMsg){
        byte[] msg = stringMsg.getBytes();
        ArrayList<Byte> msgToSend = new ArrayList<Byte>();
        for(byte n : msg) {
            msgToSend.add(n);
        }
        byte aZero = 48;
        byte aOne = 49;
        byte aTwo = 50;
        byte aThree = 51;
        byte aFour = 52;

        msgToSend.replaceAll(e -> {
            if (e == aZero) e = (byte) 0;
            else if (e == aOne) e = (byte) 1;
            else if (e == aTwo) e = (byte) 2;
            else if (e == aThree) e = (byte) 3;
            else if (e == aFour) e = (byte) 4;
            return e;
        });

        byte[] msgResult = new byte[msgToSend.size()];
        for(int i = 0; i < msgToSend.size(); i++) {
            msgResult[i] = msgToSend.get(i);
        }
        return msgResult;
    }

    /**
     * Translates a given byte array to a string
     * @param msg The array to be translated
     * @param len The length of the portion of the array to be translated
     * @return Returns the translated string
     */
    public static String translateMsg(byte[] msg, int len){
        byte[] msgToSend = Arrays.copyOfRange(msg,0, len);
        StringBuilder builtString = new StringBuilder();

        for (byte e : msgToSend)
        {
            if (e == (byte) 0) builtString.append("0");
            else if (e == (byte) 1) builtString.append("1");
            else if (e == (byte) 2) builtString.append("2");
            else if (e == (byte) 3) builtString.append("3");
            else if (e == (byte) 4) builtString.append("4");
            else builtString.append((char) e);

        }

        return builtString.toString();
    }

    /**
     * Checks the validity of the byte message being read (if it follows the pattern we set of 0[12]sometext0sometext0)
     * @param msg the message being checked
     * @param len the length of the message
     * @return Returns true if the message follows the pattern, false otherwise
     */
    public static boolean validateData(byte[] msg, int len)
    {
        //check if: number of 0 bytes == 3, second byte is 1 or 2, last byte is 0 and there is text before it

        //check specific bytes (0, 1 and final byte):
        if ((msg[0] != 0 || msg[len-1] != 0 || msg[len-2] < 45) || (msg[1] != 1 && msg[1] != 2 && msg[1] != 3 && msg[1] != 4)) return false;

        int zeroCount = 0;
        int invalidCharacterCount = 0;
        //check number of 0 bytes
        for (int i = 0; i < len; i++)
        {
            //if (msg[i] == 0) zeroCount++;
            if (msg[i] < 46) invalidCharacterCount ++;
        }

        if (invalidCharacterCount > 1) return false;
        return true;
    }

    /**
     * Print the Bytes and the bytes as a String
     * @param data the data to be printed
     * @param len the length of the message
     */
    public static void printDataInfo(byte[] data, int len)
    {
        String stringMsg = translateMsg(data, len);
        System.out.println("String -> " + stringMsg);
        System.out.println("Bytes -> " + Arrays.toString(Arrays.copyOfRange(data,0, len)).replace(",", "")
                .replace("[", "")
                .replace("]", "")
                .trim());
    }
}